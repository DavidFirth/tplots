% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data.R
\docType{data}
\name{UK_GE_2024}
\alias{UK_GE_2024}
\title{Vote Counts at the United Kingdom General Election of 2024}
\format{
\subsection{\code{UK_GE_2024}}{

A data frame with 650 rows and 30 columns:
\describe{
\item{ONS.ID}{Character string: the Office for National Statistics identifier for the constituency}
\item{ONS.region.ID}{Character string: the Office for National Statistics identifier for the constituency's region}
\item{Constituency.name}{Character string: the name of the constituency}
\item{Region.name}{Character string: the name of the region}
\item{Country.name}{Character string: the name of the constituency's nation within the UK, one of \code{"England"}, \code{"Northern Ireland"}, \code{"Scotland"}, \code{"Wales"}}
\item{Constituency.type}{Character string: one of \code{"County"}, \code{"Burgh"}, \code{"Borough"}}
\item{Member.first.name}{Character string: the first name of the elected MP}
\item{Member.surname}{Character string: the surname of the elected MP}
\item{Member.gender}{Character string: one of \code{"Male"}, \code{"Female"}}
\item{Result}{Character string: which party held the seat or gained the seat from which other}
\item{First.party}{Character string: which party won the seat}
\item{Second.party}{Character string: which party came second}
\item{Electorate}{Integer: the number of registered voters in the constituency}
\item{Valid.votes}{Integer: the number of valid voting papers counted}
\item{Invalid.votes}{Integer: the number of invalid voting papers counted}
\item{Majority}{Integer: difference between votes for the winning and second parties}
\item{Con}{Integer: votes for the Conservative Party}
\item{Lab}{Integer: votes for the Labour Party}
\item{LD}{Integer: votes for the Liberal Democrats}
\item{RUK}{Integer: votes for Reform UK}
\item{Green}{Integer: votes for the Green Party}
\item{SNP}{Integer: votes for the Scottish National Party}
\item{PC}{Integer: votes for Plaid Cymru}
\item{DUP}{Integer: votes for the Democratic Unionist Party}
\item{SF}{Integer: votes for Sinn FÃ©in}
\item{SDLP}{Integer: votes for the Social Democratic and Labour Party}
\item{UUP}{Integer: votes for the Ulster Unionist Party}
\item{APNI}{Integer: votes for the Alliance Party of Northern Ireland}
\item{All.other.candidates}{Integer: votes for all candidates not in the above parties}
\item{Of.which.other.winner}{Integer: votes for the winning candidate if not in any of the above-named parties}
}
}
}
\source{
\url{https://researchbriefings.files.parliament.uk/documents/CBP-10009/HoC-GE2024-results-by-constituency.csv}, downloaded 28th August 2024.
}
\usage{
UK_GE_2024
}
\description{
This is the official spreadsheet of constituency vote counts at the General
Election held in July 2024.  Each row of the data represents one
parliamentary constituency, i.e., one seat in the House of Commons.
}
\examples{
##  Calculate main-party vote shares (\%) in each UK nation
parties <- c("Con", "Lab", "LD", "RUK", "Green", "SNP", "PC", "DUP", "SF",
             "SDLP", "UUP", "APNI")
votes <- UK_GE_2024[, c("Constituency.name", "Country.name", "First.party", parties)]
votes $ total <- rowSums(votes[, -(1:3)])
nation_totals <- aggregate(votes[, parties], by = list(nation = votes $ Country.name),
                           FUN = sum)
row.names(nation_totals) <- nation_totals $ nation
nation_totals <- nation_totals[, parties]
nation_shares <- round(100 * nation_totals / rowSums(nation_totals[, parties]), 0)
print(nation_shares)

##  Draw a ternary plot of vote shares among the three "traditional" parties, for
##  constituencies in England at the 2024 UK General Election
England <- UK_GE_2024[UK_GE_2024$Country.name == "England", ]
#  Remove the Speaker's seat, which is not contested:
England <- England[England$Constituency.name != "Chorley", ]
#  Set up political party colours for plotting points and backgrounds
party_names <- c("Con", "Lab", "LD", "RUK", "Green", "Ind")
party_colours <- c("#0087DC", "#E4003B", "#FAA61A", "cyan", "limegreen", "white")
names(party_colours) <- party_names
backgrounds <- c("#a8ddff", "#FFcccc", "#fddba3")
names(backgrounds) <- party_names[1:3]

#  Now make the ternary plot
tplot_new(scale = 1.1)
grid::grid.draw(ternary_thirds(fill = backgrounds, gp = grid::gpar(col = "transparent")))
point_colours <- party_colours[England $ First.party]
#  Plot the 3 traditional parties first so that other seat winners don't get buried
plot_first <- England $ First.party \%in\% c("Con", "Lab", "LD")
grid::grid.draw(ternary_points(nby3 = as.matrix(England[plot_first, party_names[1:3]]),
               pch = 21, size = grid::unit(0.6, "char"),
               gp = grid::gpar(fill = point_colours[plot_first])))
grid::grid.draw(ternary_points(nby3 = as.matrix(England[!plot_first, party_names[1:3]]),
               pch = 21, size = grid::unit(0.6, "char"),
               gp = grid::gpar(fill = point_colours[!plot_first])))
grid::grid.draw(ternary_text(label = c("Con", "Lab", "LD"),
             nby3 = diag(3) - c(0.01, 0.01, 0.015),
             neg_action = NULL))
grid::grid.draw(grid::grid.legend(paste(party_names, "won"), pch = 21, vgap = 0.8,
            gp = grid::gpar(fill = party_colours),
            vp = grid::viewport(x = 0.8, y = 0.75, width = 0.2, height = 0.2)))
}
\keyword{datasets}
